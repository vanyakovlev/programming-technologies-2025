# Лабораторная работа №2: Простейший чат-бот в Telegram

## Цель работы

Цель лабораторной работы — получение навыков работы с библиотекой Aiogram, связка API OpenAI и написанного бота.

## Инструменты и настройки

- **Язык программирования**: Python.
- **Библиотеки**:
  - `openai` — для работы с API.
  - `dotenv` — для загрузки переменных окружения (например, API-ключ).
  - `aiogram` - для работы с Telegram API, предоставляет удобный асинхронный интерфейс для создания ботов, обработки сообщений, команд и взаимодействия с пользователем.
  

## Реализованные задачи

В коде были реализованы следующие задачи:

1. **Добавление к ассистенту системный промпт**:
    
    ```
    from config import api_key, prompt

    response = await client.responses.create(
    model="gpt-4.1-nano",
    input=[{"role": "system", "content": prompt}] + [{"role": "user", "content": f"Пользователя зовут {user_name}"}] + dialog_history_actual,
    )
    ```

    Переменная system_prompt извлекается из файла .env с помощью os.getenv("SYSTEM_PROMPT"). Системный промпт помогает задавать общий контекст для общения с моделью, например, как она должна вести себя.

    **Результат работы:**

    Бот генерирует ответы, используя системный контекст.

    ![Системный промт](./Screenshots/систем%20промпт.png)


2. **Добавление функции обращения к пользователю по имени**:
    Для того чтобы бот знал имя пользователя, используем атрибут message.from_user.full_name
    ```
    response = await get_response(message.text, message.from_user.id, message.from_user.full_name, client)
    ```
    и передаем в функцию запроса к ChatGPT
    ```
    ... + [{"role": "user", "content": f"Пользователя зовут {user_name}"}] + ...
    ```
    
    ![Обращение к пользователю](./Screenshots/знает%20имя%20п.png)
   

3. **Добавление хранения сообщений и поддержку контекста диалога**:
    ```
    def create_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS dialog_history (
        user_id TEXT PRIMARY KEY,
        history TEXT
    )
    ''')
    conn.commit()
    conn.close()

    create_table()

    def get_dialog_history(user_id: str):
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT history FROM dialog_history WHERE user_id = ?", (user_id,))
        result = cursor.fetchone()
        if result:
            dialog_history = json.loads(result[0])
        else:
            dialog_history = []
        conn.close()
        return dialog_history

    def save_dialog_history(user_id: str, dialog_history_actual: list):
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("""
        INSERT OR REPLACE INTO dialog_history (user_id, history)
        VALUES (?, ?)
        """, (user_id, json.dumps(dialog_history_actual)))
        conn.commit()
        conn.close()
    ```
   Для того, чтобы ИИ помнил контекст общения с пользователем, была реализована система ведения истории диалога. Контекст переписки ограничивался 50 последними сообщениями. У каждого пользователя свой отдельный список. 

   Для упрощения задачи и быстрого прототипирования я решил использовать файл SQLite для хранения истории сообщений и подключаться к нему, что позволяет эффективно управлять данными без необходимости использования более сложных баз данных. Это обеспечило простоту реализации и ускорение процесса разработки, что идеально подходит для учебного прототипа.

4. **Добавление команды /resetcontext, которая будет сбрасывать контекст диалога**
    ```
    @dp.message(Command("resetcontext"))
    async def reset_context(message: Message):
        user_id = message.from_user.id  # Получаем user_id из сообщения

        if user_id in dialog_history:
            dialog_history[user_id] = []  # Очищаем историю для данного пользователя
            await message.answer("История диалога сброшена. Можешь начинать новый разговор!")
        else:
            await message.answer("История не была найдена. Начни новый разговор!")
    ```
    Для реализации команды `/resetcontext`, которая сбрасывает контекст диалога, я создал обработчик для этой команды, который проверяет, есть ли сохраненная история для конкретного пользователя, используя его уникальный `user_id`. Когда пользователь отправляет команду `/resetcontext`, я извлекаю его user_id из сообщения с помощью `message.from_user.id`. Затем, проверяя, существует ли запись этого `user_id` в словаре `dialog_history`, я очищаю соответствующую историю, присваивая пустой список, что фактически сбрасывает контекст диалога для этого пользователя. После этого отправляется сообщение, подтверждающее, что история была сброшена и можно начать новый разговор. Если история для этого пользователя еще не была сохранена, бот сообщает, что история не найдена и предлагает начать новый разговор с чистого листа.

    ![Ресет контекст до реализации](./Screenshots/До%20ресет%20команды.png)

    ![Ресет контекст после реализации](./Screenshots/После%20ресет%20команды.png)


4. **Добавление поддержки отправки изображений (без их обработки нейронкой).**
    ```
    else:
            await message.answer(f"Спасибо, что отправили  {str(message.content_type)[12:]}, но я работаю только с обычными сообщениями)")
    ```

    Для обработки сообщений, отличных от текста (например, изображений, видео и других медиа), я добавил проверку типа сообщения с помощью атрибута `content_type` объекта `Message`. В коде я использую условие `if message.text`, которое проверяет, является ли сообщение текстовым. Если сообщение не является текстом, то с помощью `else` блоки проверяется, что было отправлено, и бот отвечает пользователю в зависимости от типа содержимого.

    Если отправленное сообщение является изображением, видео, аудио или другим медиа, бот использует атрибут `message.content_type` для того, чтобы определить тип контента. Я применил срез для строки `message.content_type`, чтобы красиво вывести тип отправленного контента в сообщении для пользователя, например, "Спасибо, что отправили фото", если было отправлено изображение.


    ![Отправка изображения](./Screenshots/Реакция%20на%20изобаржение.png)

    ![Отправка видео](./Screenshots/Реакция%20на%20видео.png)

## Вывод

В ходе лабораторной работы был создан Telegram-бот с использованием библиотеки `Aiogram` и интеграцией с `API OpenAI`. Бот поддерживает системный промпт для задания контекста общения, обращается к пользователю по имени и запоминает историю диалогов с помощью базы данных. Реализована команда `/resetcontext` для сброса истории, а также обработка различных типов медиа (изображений, видео и других файлов). В результате работы были получены навыки работы с асинхронным программированием, Telegram API и хранением данных, а также реализована поддержка контекста и взаимодействие с пользователем на более персонализированном уровне.

