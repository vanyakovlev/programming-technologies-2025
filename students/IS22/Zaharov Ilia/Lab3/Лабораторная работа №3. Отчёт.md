# Лабораторная работа №3. Отчёт.

Цель: научиться использовать векторные базы данных и семантический поиск для обработки текстовых данных и потенциальной интеграции с LLM.

План:
- Настройка окружения;
- Создание модуля для работы с милвусом;
- Парсинг текстовых файлов;
- Задания.

Для успешного выполнения лабораторной работы, первым делом был скачан архив со всеми необходимыми файлами. После чего, было принято решение открыть данную рабочую
область в `devcontainer` и для того, чтобы двигаться дальше, нужно понять, для чего он вообще нужен.

`Devcontainer` — это инструмент для создания предсказуемых и портативных сред разработки внутри Docker-контейнеров. Он решает проблему «работает на моей машине»,
автоматически настраивая единое окружение (софт, зависимости, инструменты) для всего проекта.
Как это работает и зачем нужно:
- Изоляция и воспроизводимость: Все зависимости (библиотеки, версии Python, системные пакеты) упакованы в контейнер.
- Это гарантирует, что приложение будет одинаково работать у всех в команде и на сервере.
- Быстрый старт: Новый разработчик может начать работу одной командой (Reopen in Container), не тратя часы на ручную настройку окружения.
- Единая среда: Инструменты форматирования, линтеры, расширения редактора кода можно предустановить, обеспечивая единый стандарт кода.
- Безопасность экспериментов: Можно тестировать новые версии зависимостей, не ломая основную систему.

Практический пример: Вместо инструкции «установите Python 3.12, torch, CUDA 11.8 и настройте переменные окружения» вы просто открываете проект в VS Code,
и devcontainer автоматически разворачивает готовую к работе среду.

Итак, после применения вышеупомянутой команды, мы имеем 5 контейнеров в docker:

![Среда разработки devcontainer](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image1.png)

Далее, когда среда была подготовлена, было принято решение проверить, всё ли работает в "штатном режиме". Для этого в терминале при помощи команды
`python example_usage.py` был запущен описанный файл. Вот какой результат был получен:

![Результат пробного запуска 1](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image2.png)

На данном скриншоте видно, что программа успешно запустилась, однако стоит заметить, что запустилась она на мощностях процессора, что не совсем хорошо для нашей работы. После удачной проверки работоспособности рабочей среды, было принято решение приступить к заданиям данной лабораторной работы.

## Задание №1. Запуск проекта при помощи GPU.
Так как большинство современных процессоров работают в однопоточном режиме, проект при запуске на его мощностях будет обрабатываться несколько медленнее. В связи
с этим было принято решение использовать мощности видеокарты (GPU) для того, чтобы ускорить работу проекта, т.к. графические процессоры умеют работать в многопоточном
режиме. Для того, чтобы проект использовал мощности видеокарты, нужно было добавить в `docker-compose` файл следующую строку:

![Добавление строчки в docker compose](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image6.png)

Так как в файлах нашего проекта есть нижеописанные строчки, нам не пришлось ничего делать, кроме добавления строчки в `docker compose`:

![Проверка устройства, использующегося для запуска](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image7.png)

Данные строки кода из файл лабораторной работы `milvus_client.py` помогает нам определить, какое устройство можно использовать для запуска программы. В данном случае, это видеокарта, так как выше мы указали в `docker-compose` файле, что нужно использовать её мощности.

![Устройство выбрано верно](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image8.png)

После данных манипуляций, проект стал использовать мощность GPU и работать в разы быстрее. Перейдём к слоедующему заданию.

## Задание №2. Разработка API для взаимодействия с Milvus.
На данном этапе необходимо разработать базовое API для взаимодействия с MIlvius. Для начала, давайте более детально разберёмся, что такое Milvus и зачем он нужен.
Milvus — это специализированная база данных, созданная для работы с векторными данными (эмбеддингами), которые генерируют нейросетевые модели.
Главная задача и принцип работы:
- Решает проблему семантического поиска: Вместо поиска по точному совпадению слов (как в Google) Milvus ищет по смыслу. Например, по запросу «домашнее животное, которое ловит мышей» найдёт текст про кошек.
- Как это работает: Тексты, изображения или аудио с помощью моделей вроде sentence-transformers преобразуются в векторы — наборы чисел. Milvus хранит эти векторы и умеет молниеносно находить самые похожие (ближайшие соседи) по метрикам вроде косинусного расстояния.
- Ключевые преимущества: Высокая скорость поиска по миллиардам векторов, горизонтальная масштабируемость и удобная интеграция с современным ML-стеком (PyTorch, TensorFlow).

По сути, мы пишем API для взаимодействия с базой данных, но которая работает не с таблицами, а векторами. Для написания API это не имеет большого значения, т.к.
API мы всё равно будем писать согласно утверждённым стандартам, правилам и рекомендациям. Итак, Milvus имеет несколько главных структур, это:
- Collection (Коллекция). Аналог таблицы в реляционной БД. Это контейнер верхнего уровня для хранения векторов и связанных с ними данных;
- Partition (Раздел). Внутреннее разделение коллекции для оптимизации. Помогает организовать данные по логическим категориям для ускорения запросов (например, разделение по дате или категории товара);
- Field (Поле)
Отдельный элемент данных внутри коллекции. Бывает трёх основных типов:
  - Векторное поле (Vector Field): Хранит сами векторные эмбеддинги (например, поле embedding типа FloatVector);
  - Скалярное поле (Scalar Field): Хранит обычные метаданные — ID, текст, числа (например, book_title, year);
  - Первичный ключ (Primary Key): Специальное скалярное поле для уникальной идентификации каждой сущности (обычно целочисленное int64 или строковое VarChar).
- Entity (Сущность / Запись). Единая запись, соответствующая одному вектору и его связанным метаданным. Это полный набор значений всех полей схемы для одного объекта (например, один вектор + название одной книги + её год издания);
- Index (Индекс). Структура для ускорения поиска похожих векторов. Создаётся поверх векторного поля. Без индекса Milvus выполняет полный перебор (flat search), что медленно для больших объёмов;
- Segment (Сегмент). Базовая единица хранения и поиска внутри Milvus. Данные в коллекции автоматически разбиваются на сегменты для управления памятью и параллельной обработки;
- Alias (Псевдоним). Понятное имя для коллекции, которое можно динамически переназначать. Полезно для операций обновления без простоя: можно создать новую версию коллекции под тем же псевдонимом, и клиенты увидят её автоматически.

Именно с этими видами структур нам придётся работать в API. По итогу написания, получилось стандартное API, способное работать с базой данных Milvus:

![API](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image9.png)

К проекту был подключён `swagger` для более удобного взаимодействия с ним. Вот пример работы API:

![GET-запрос](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image10_1.png)

После выполнения `GET-запроса`, мы получаем стандартный `JSON`, в котором описаны коллекции, содержащиеся в данный момент в нашей базе данных.
Далее, было принято решение проверить как работает `POST-запрос`, с помощью которого можно создавать коллекции:

![POST-запрос](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image10.png)

Как видно из скриншота выше, `POST-запрос` отрабатывает так же корректно, как и `GET`. При создании коллекции, мы указываем параметры, такие как:

- collection_name (string): Имя коллекции, которое вы хотите создать. Имя должно быть уникальным в рамках базы данных;
- dimension (integer): Размерность векторов, которые будут храниться в этой коллекции. Например, если вы используете эмбеддинги размером 128, то dimension будет 128;
- description (string, опционально): Описание коллекции. Может быть пустой строкой;
- metric_type (string): Метрика, используемая для вычисления расстояния между векторами. В данном случае указано "COSINE" (Текстовые эмбеддинги, нормализованные векторы). Другие возможные значения: "L2" (евклидово расстояние), "IP" (внутреннее произведение) и т.д.;
- model_name (string): Имя модели, которая используется для создания векторов. Это поле может быть использовано для отслеживания, но не является обязательным для работы Milvus. В некоторых случаях может быть пустым.

Далее, была проделана проверка работы `DELETE-запроса`, который, как видно ниже, так же как и два предыдущих работает исправно:

![DELETE-запрос](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image11.png)

В данном запросе реализована простая логика: мы вводим имя нужной нам коллекции, она находится в базе, затем удаляется из неё.
Ниже представлен скриншот с логами рабты API:

![Логи работы API](https://github.com/NP1R777/programming-technologies-2025/blob/main/students/IS22/Zaharov%20Ilia/Lab3/pictures/image12.png)

Как мы видим, по ходу работы API не возникало никаких ошибок и сбоев. Всё работает исправно!

## Вывод
В данной лабораторной работе были получены следующие навыки:

- Базовое понимание работы `devcontainer` и зачем он нужен;
- Знакомство с векторной базой данных `Milvus`;
- Улучшение навыков работы с веб-фреймворком `Django` и разработки на нём простого API для работы с `Milvus`.

Все цели были достигнуты, навыки получены или улучшены, по итогу работы появилось понимание о том, что такое веткторная база данных и зачем она нужна ИИ-агентам.
