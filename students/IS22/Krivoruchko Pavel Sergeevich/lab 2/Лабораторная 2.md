# Лабораторная работа №2

**Цель работы:** Реализовать Telegram-бота с интеграцией OpenAI, добавить системный промпт с изюминкой и сделать так, чтобы бот обращался к пользователю по имени.

Бот был успешно запущен и протестирован в Telegram.

![Описание картинки](pic/0.png)

## 1) Добавление системного промпта к ассистенту

Системный промпт определяет поведение бота, его стиль общения и особенности ответов. В данной работе был использован эксцентричный и слегка странный промпт, который подчёркивает, что бот работает в Telegram и может вставлять необычные комментарии.

![Описание картинки](pic/1.png)

```python
SYSTEM_PROMPT = "Ты - странный, эксцентричный помощник в Telegram. \
Ты понимаешь, что общаешься через этот чат-бот, иногда упоминаешь это в своих ответах. \
Иногда вставляешь неожиданные комментарии или причудливые замечания, но всё равно отвечаешь на вопросы пользователя. \
Помни последние сообщения в диалоге и иногда ссылайся на них в необычной форме. \
Не придумывай факты, но можешь слегка преувеличивать детали или использовать странные сравнения. \
Каждый ответ - смесь полезной информации, лёгкого абсурда и странного юмора, чтобы было понятно, что с тобой что-то не так."
```

- Этот промпт задаёт общую «личность» бота.
- Он делает ответы ИИ информативными, но с лёгкой причудливостью.
- В дальнейшем в промпт можно подставлять имя пользователя, чтобы бот обращался к нему по имени.

## 2) Обращение к пользователю по имени

Для того чтобы бот мог персонализировать ответы, в систему был добавлен механизм подстановки имени пользователя через `{user_name}` в системном промпте.

![Описание картинки](pic/2.png)

### gpt.py

```python
from openai import AsyncOpenAI
from config import OPENAI_API_KEY, SYSTEM_PROMPT
import logging

client = AsyncOpenAI(api_key=OPENAI_API_KEY)

async def get_response(message: str, user_name: str, client: AsyncOpenAI) -> str:
    system_prompt = SYSTEM_PROMPT.format(user_name=user_name or "друг")
    try:
        response = await client.responses.create(
            model="gpt-5-nano",
            input=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": message}
            ]
        )
        return response.output_text
    except Exception as e:
        logging.error(f"Error occurred: {e}")
        return "Произошла ошибка при получении ответа"
```

- `user_name` передаётся в функцию отдельно.
- В промпт подставляется имя пользователя, чтобы ИИ обращался к нему лично.
- Обработка ошибок позволяет безопасно выводить сообщение при сбое.

### messages.py

```python
from utils.loader import dp
import logging
from aiogram.types import Message
from utils.gpt import get_response, client

@dp.message()
async def message_handler(message: Message) -> None:
    try:
        user_name = message.from_user.first_name or "друг"
        response = await get_response(message.text, user_name, client)
        await message.answer(response)
    except Exception as e:
        logging.error(f"Error occurred: {e}")
        await message.answer("Произошла ошибка при получении ответа")
```

- Хендлер получает имя пользователя через `message.from_user.first_name`.
- Вызов функции `get_response` передаёт текст сообщения, имя пользователя и объект клиента OpenAI.
- Ответ бота отправляется пользователю через `message.answer`.

### Системный промпт с подстановкой имени

```python
SYSTEM_PROMPT = "Ты - странный, эксцентричный помощник в Telegram. \
Ты понимаешь, что общаешься через этот чат-бот и всегда обращаешься к пользователю по имени. \
Иногда вставляешь неожиданные комментарии или причудливые замечания, но всё равно отвечаешь на вопросы {user_name}."
```

- `{user_name}` заменяется на имя пользователя при каждом сообщении.
- Это позволяет боту персонализировать ответы и усиливает эффект «живого общения».

## 3) Добавление хранения сообщений (создание базы данных)

Изначально, для упрощения, использовался словарь `user_histories`, который хранил переписку пользователей в оперативной памяти. Для сохранения истории взаимодействия с пользователями была реализована система хранения сообщений с использованием **базы данных**. В данной реализации используется база данных PostgreSQL для хранения истории переписки.

Каждому пользователю соответствует запись в таблице **`dialog_history`**, где хранятся его сообщения. Каждое сообщение имеет два поля:

- **`role`** — роль отправителя (пользователь или ассистент),
- **`content`** — содержание сообщения.

История переписки хранится в формате **JSON**, что позволяет эффективно обновлять и извлекать данные, а также поддерживать контекст диалога.

### gpt.py

```python
from openai import AsyncOpenAI
from config import OPENAI_API_KEY, SYSTEM_PROMPT
import logging

client = AsyncOpenAI(api_key=OPENAI_API_KEY)

user_histories = {}

async def get_response(message: str, user_id: int, user_name: str, client: AsyncOpenAI) -> str:
    system_prompt = SYSTEM_PROMPT.format(user_name=user_name or "друг")

    if user_id not in user_histories:
        user_histories[user_id] = []

    history = user_histories[user_id]
    history.append({"role": "user", "content": message})

    if len(history) > 6:
        history.pop(0)

    input_messages = [{"role": "system", "content": system_prompt}] + history

    try:
        response = await client.responses.create(
            model="gpt-4.1-nano",
            input=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": message}
            ]
        )
        ai_message = response.output_text

        history.append({"role": "assistant", "content": ai_message})

        return ai_message

    except Exception as e:
        logging.error(f"Error occurred: {e}")
        return "Произошла ошибка при получении ответа"
```

**Пояснение:**

- `user_histories` играет роль базы данных, где хранятся последние сообщения пользователей.
- Для экономии памяти хранится только **6 последних сообщений**.

### database.py

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, String, Text
from config import DATABASE_URL
import json

engine = create_async_engine(DATABASE_URL, echo=False)

AsyncSessionLocal = sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

Base = declarative_base()

class DialogHistory(Base):
    __tablename__ = "dialog_history"

    user_id = Column(String, primary_key=True)
    history = Column(Text)

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def save_dialog_history(user_id: int, dialog_history_actual: list):
    async with AsyncSessionLocal() as session:
        user_id_str = str(user_id)
        obj = await session.get(DialogHistory, user_id_str)

        if obj:
            obj.history = json.dumps(dialog_history_actual)
        else:
            obj = DialogHistory(
                user_id=user_id_str,
                history=json.dumps(dialog_history_actual)
            )
            session.add(obj)
        await session.commit()
```

**Пояснение:**

В файле **`database.py`** была реализована база данных для хранения истории диалогов. Создана таблица **`dialog_history`**, которая сохраняет историю сообщений для каждого пользователя в формате JSON. В коде использован **SQLAlchemy** для асинхронной работы с PostgreSQL. Добавлены функции:

1. **`init_db()`** - инициализация базы данных, создание таблиц.
2. **`save_dialog_history(user_id, dialog_history_actual)`** - сохранение или обновление истории сообщений пользователя в базе данных.

**Что изменилось:**

- Вместо использования словаря `user_histories` теперь используется база данных, куда сохраняется история сообщений.
- **6 последних сообщений** сохраняются в базе данных и используются для создания контекста диалога.
- Теперь диалог с ботом хранится в базе данных, но никак не используется.

## 4) Добавление поддержки контекста диалога

Теперь бот поддерживает контекстный диалог. Это означает, что он учитывает не только текущее сообщение, но и несколько предыдущих, что делает ответы более логичными и связными.

```python
async def get_dialog_history(user_id: int):
    async with AsyncSessionLocal() as session:
        user_id_str = str(user_id)
        result = await session.get(DialogHistory, user_id_str)
        if result and result.history:
            return json.loads(result.history)
        return []
```

В файл **`database.py`** была добавлена функция **`get_dialog_history(user_id)`** - получение истории сообщений пользователя из базы данных.

### gpt.py

```python
from openai import AsyncOpenAI
from config import OPENAI_API_KEY, SYSTEM_PROMPT
from database import get_dialog_history, save_dialog_history
import logging

client = AsyncOpenAI(api_key=OPENAI_API_KEY)

async def get_response(message: str, user_id: int, user_name: str, client: AsyncOpenAI) -> str:
    history = await get_dialog_history(user_id)
    history.append({"role": "user", "content": message})
    if len(history) > 6:
        history = history[-6:]
    input_messages = [
        {
            "role": "system",
            "content": SYSTEM_PROMPT.format(user_name=user_name or "друг")
        }
    ] + history

    try:
        response = await client.responses.create(
            model="gpt-4.1-nano",
            input=input_messages
        )
        ai_message = response.output_text
        history.append({"role": "assistant", "content": ai_message})
        await save_dialog_history(user_id, history)
        return ai_message

    except Exception as e:
        logging.error(f"Error: {e}")
        return "Не удалось получить ответ"
```

**Пояснение:**

Теперь бот использует историю сообщений для каждого пользователя, что позволяет учитывать контекст в ответах.

### messages.py

```python
from utils.loader import dp
import logging
from aiogram.types import Message
from utils.gpt import get_response, client

@dp.message()
async def message_handler(message: Message) -> None:
    try:
        user_id = message.from_user.id
        user_name = message.from_user.first_name or "друг"
        if message.text:
            response = await get_response(message.text, user_id, user_name, client)
            await message.answer(response)
    except Exception as e:
        logging.error(f"Error occurred: {e}")
        await message.answer("Произошла ошибка при получении ответа")
```

После добавления поддержки контекста:

- Бот теперь **запоминает предыдущие сообщения**.
- Он **отвечает в зависимости от истории диалога**, поддерживая связность и контекст.
- История диалога сохраняется в базе данных, что позволяет корректно **обновлять контекст при каждом новом сообщении**.

### 5) Добавление команды `/reset-context`, сбрасывающей контекст диалога

Для реализации возможности очистки истории сообщений пользователя была добавлена команда `/reset-context`.
Она полностью удаляет сохранённый контекст диалога конкретного пользователя из словаря `user_histories`.
После вызова команды бот уведомляет о сбросе истории, позволяя начать новый разговор с чистого состояния.

![Описание картинки](pic/5.png)

### messages.py

```python
@dp.message(Command("resetcontext"))
async def reset_context(message: Message):
    user_id = message.from_user.id

    await save_dialog_history(user_id, [])
    await message.answer("История диалога очищена. Можешь начинать заново.")
```

Для удобства команда `/resetcontext` также была добавлена в список **быстрых команд Telegram** через метод `set_my_commands()`, что позволяет вызывать её из меню.

### 6) Добавление поддержки отправки изображений

На данном этапе была добавлена базовая обработка изображений.
Если пользователь отправляет фотографию, бот определяет это событие и отвечает текстом, без какой-либо обработки изображения нейросетью.

![Описание картинки](pic/6.png)

```python
@dp.message()
async def message_handler(message: Message) -> None:
    try:
        user_id = message.from_user.id
        user_name = message.from_user.first_name or "друг"
        if message.text:
            response = await get_response(message.text, user_id, user_name, client)
            await message.answer(response)
        elif message.photo:
            await message.answer(f"Извините, но я не работаю с фотографиями")
    except Exception as e:
        logging.error(f"Error occurred: {e}")
        await message.answer("Произошла ошибка при получении ответа")
```

### **Общий вывод**

В ходе выполнения лабораторной работы был реализован Telegram-бот с поддержкой диалогового взаимодействия и создана база данных для хранения истории сообщений. Добавлены команды, такие как `/reset-context`, для сброса истории переписки, а также базовая обработка изображений, при которой бот уведомляет пользователя о невозможности обработки фотографий.

Бот корректно сохраняет и очищает контекст диалога, взаимодействует с пользователем в удобной форме. Цели лабораторной работы достигнуты: бот стал более устойчивым и интерактивным, готовым к дальнейшему расширению функциональности.
